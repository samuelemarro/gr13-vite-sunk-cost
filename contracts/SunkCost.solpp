// SPDX-License-Identifier: MIT
/// @title Sunk Cost Game implementation for GR13 Hackathon
/// @author Samuele Marro

pragma soliditypp ^0.8.0;

struct Game {
    vitetoken tokenId;
    uint256 expiration;
    uint256 initialBuyIn;
    uint256 currentBuyIn;
    uint256 currentPot;
    uint256 buyInIncrement;
    uint256 burnAmount;
    uint256 extension;

    address currentWinner;

    bool claimed;
}

contract SunkCost {
    mapping(uint256 => Game) public games;
    uint256 private nGames = 0;

    // ==Getters==

    function numGames() public view returns (uint256) {
        return nGames;
    }

    function exists(uint256 _gameId) public view returns (bool) {
        return _gameId < nGames;
    }

    function tokenId(uint256 _gameId) external view returns (vitetoken) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].tokenId;
    }

    function expiration(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].expiration;
    }

    function expired(uint256 _gameId) external view returns (bool) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].expiration < block.timestamp;
    }

    function initialBuyIn(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].initialBuyIn;
    }

    function currentBuyIn(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].currentBuyIn;
    }

    function currentPot(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].currentPot;
    }

    function buyInIncrement(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].buyInIncrement;
    }

    function burnAmount(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].burnAmount;
    }

    function extension(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].extension;
    }

    function currentWinner(uint256 _gameId) external view returns (address) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].currentWinner;
    }

    function claimed(uint256 _gameId) external view returns (bool) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].claimed;
    }

    // ==Game Management==

    function createGame(vitetoken _tokenId, uint256 _expiration, uint256 _initialBuyIn, uint256 _buyInIncrement, uint256 _burnAmount, uint256 _extension) external payable {
        require(_expiration > block.timestamp, "Game cannot end in the past");
        require(msg.token == _tokenId, "Token ID mismatch");
        require(msg.value == _initialBuyIn, "Transaction value should cover initial buy-in");

        uint256 gameId = nGames;

        games[gameId].tokenId = _tokenId;
        games[gameId].expiration = _expiration;
        games[gameId].initialBuyIn = _initialBuyIn;
        games[gameId].currentBuyIn = _initialBuyIn + _buyInIncrement;
        // games[gameId].currentPot = 0;
        games[gameId].buyInIncrement = _buyInIncrement;
        games[gameId].burnAmount = _burnAmount;
        games[gameId].extension = _extension;
        games[gameId].currentWinner = msg.sender;
        // games[gameId].claimed = false;
        nGames++;

        // TODO: burnAmount
    }

    function buy(uint256 _gameId) public payable {
        require(exists(_gameId), "Game does not exist");
        require(games[_gameId].expiration > block.timestamp, "Game is expired");
        require(msg.token == games[_gameId].tokenId, "Token ID mismatch");
        require(msg.value == games[_gameId].currentBuyIn, "Transaction value should cover current buy-in");

        games[_gameId].currentPot += games[_gameId].currentBuyIn;
        games[_gameId].currentBuyIn += games[_gameId].buyInIncrement;

        // TODO: Handle frontrunning

        // TODO: burnAmount
        games[_gameId].expiration += games[_gameId].extension;

        games[_gameId].currentWinner = msg.sender;
    }

    function claimReward(uint256 _gameId) public {
        require(exists(_gameId), "Game does not exist");
        require(games[_gameId].expiration <= block.timestamp, "Game is not over yet");
        require(msg.sender == games[_gameId].currentWinner, "Sender must be winner");
        require(!games[_gameId].claimed, "Reward has already been claimed");

        payable(msg.sender).transfer(games[_gameId].tokenId, games[_gameId].currentPot);
        games[_gameId].claimed = true;
    }
}