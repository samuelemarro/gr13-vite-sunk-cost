// SPDX-License-Identifier: MIT
/// @title Sunk Cost Game implementation for GR13 Hackathon
/// @author Samuele Marro

pragma soliditypp ^0.8.0;

struct Game {
    address creator;

    vitetoken tokenId;
    uint256 expiration;
    uint256 maxExpiration;
    uint256 initialBuyIn;
    uint256 currentBuyIn;
    uint256 currentPot;
    uint256 buyInIncrement;
    uint256 burnAmount;
    uint256 extension;

    address currentWinner;

    bool claimed;
}

contract SunkCost {
    event GameCreated(uint256 indexed gameId, address indexed creator);
    event BuyIn(uint256 indexed gameId, address indexed player, uint256 amount);
    event RewardCollected(uint256 indexed gameId, address indexed player, uint256 amount);

    mapping(uint256 => Game) public games;
    uint256 private nGames = 0;

    address public constant BURN_ADDRESS = "vite_00000000000000000000000000000000000000000000000000";

    // ==Getters==

    function numGames() public view returns (uint256) {
        return nGames;
    }

    function exists(uint256 _gameId) public view returns (bool) {
        return _gameId < nGames;
    }

    function creator(uint256 _gameId) external view returns (address) {
        return games[_gameId].creator;
    }

    function tokenId(uint256 _gameId) external view returns (vitetoken) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].tokenId;
    }

    function expiration(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].expiration;
    }

    function maxExpiration(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].maxExpiration;
    }

    function expired(uint256 _gameId) external view returns (bool) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].expiration < block.timestamp;
    }

    function initialBuyIn(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].initialBuyIn;
    }

    function currentBuyIn(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].currentBuyIn;
    }

    function currentPot(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].currentPot;
    }

    function buyInIncrement(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].buyInIncrement;
    }

    function burnAmount(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].burnAmount;
    }

    function extension(uint256 _gameId) external view returns (uint256) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].extension;
    }

    function currentWinner(uint256 _gameId) external view returns (address) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].currentWinner;
    }

    function claimed(uint256 _gameId) external view returns (bool) {
        require(exists(_gameId), "Game does not exist");
        return games[_gameId].claimed;
    }

    function _burn(vitetoken _tokenId, uint256 _amount) internal {
        payable(BURN_ADDRESS).transfer(_tokenId, _amount);
    }

    // ==Game Management==

    function createGame(vitetoken _tokenId, uint256 _expiration, uint256 _maxExpiration, uint256 _initialBuyIn, uint256 _buyInIncrement, uint256 _burnAmount, uint256 _extension) external payable {
        require(_expiration > block.timestamp, "Game cannot end in the past");
        require(msg.token == _tokenId, "Token ID mismatch");
        require(msg.value == _initialBuyIn, "Transaction value should cover initial buy-in");
        require(_maxExpiration >= _expiration, "Max expiration must be greater than or equal to expiration");

        uint256 gameId = nGames;

        games[gameId].creator = msg.sender;
        games[gameId].tokenId = _tokenId;
        games[gameId].expiration = _expiration;
        games[gameId].maxExpiration = _maxExpiration;
        games[gameId].initialBuyIn = _initialBuyIn;
        games[gameId].currentBuyIn = _initialBuyIn + _buyInIncrement;
        // games[gameId].currentPot = 0;
        games[gameId].buyInIncrement = _buyInIncrement;
        games[gameId].burnAmount = _burnAmount;
        games[gameId].extension = _extension;
        games[gameId].currentWinner = msg.sender;
        // games[gameId].claimed = false;
        nGames++;

        if (_burnAmount > 0) {
            _burn(_tokenId, _burnAmount);
        }

        emit GameCreated(gameId, msg.sender);
    }

    function buyIn(uint256 _gameId) external payable {
        require(exists(_gameId), "Game does not exist");
        require(games[_gameId].expiration > block.timestamp, "Game is expired");
        require(msg.token == games[_gameId].tokenId, "Token ID mismatch");
        require(msg.value == games[_gameId].currentBuyIn, "Transaction value should cover current buy-in");

        uint256 gameBurnAmount = games[_gameId].burnAmount;
        uint256 refund = msg.value - games[_gameId].currentBuyIn;

        games[_gameId].currentPot += games[_gameId].currentBuyIn;
        games[_gameId].currentBuyIn += games[_gameId].buyInIncrement;

        if (gameBurnAmount > 0) {
            _burn(games[_gameId].tokenId, gameBurnAmount);
        }

        uint256 newExpiration = games[_gameId].expiration + games[_gameId].extension;

        if (newExpiration > games[_gameId].maxExpiration) {
            newExpiration = games[_gameId].maxExpiration;
        }

        games[_gameId].expiration = newExpiration;

        games[_gameId].currentWinner = msg.sender;

        if (refund > 0) {
            // Buyer overpaid (e.g. to handle frontrunning), refund the difference
            payable(msg.sender).transfer(games[_gameId].tokenId, refund);
        }

        emit BuyIn(_gameId, msg.sender, games[_gameId].currentBuyIn);
    }

    function claimReward(uint256 _gameId) external {
        require(exists(_gameId), "Game does not exist");
        require(games[_gameId].expiration <= block.timestamp, "Game is not over yet");
        require(msg.sender == games[_gameId].currentWinner, "Sender must be winner");
        require(!games[_gameId].claimed, "Reward has already been claimed");

        games[_gameId].claimed = true;

        // Tokens are sent last to prevent re-entrancy attacks
        payable(msg.sender).transfer(games[_gameId].tokenId, games[_gameId].currentPot);

        emit RewardCollected(_gameId, msg.sender, games[_gameId].currentPot);
    }
}